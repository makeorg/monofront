import fs from 'fs';
import yaml from 'js-yaml';
import { diffLines } from 'diff';
import { Recipient, TrackEventType, TrackParameterType } from '../types';

export enum StatusType {
  IS_UP_TO_DATE = 'IS_UP_TO_DATE',
  READY_TO_BE_SAVED = 'READY_TO_BE_SAVED',
  UPDATED = 'UPDATED',
  NEED_GENERATE = 'NEED_GENERATE',
}

export class TrackingDocumentationGenerator {
  #mdTargetFile: string;

  #trackingConfigurationFile: string;

  #updatedContent: string;

  #regReplacement =
    /<auto-generated-tracking-doc>([\s\S]*?)<\/auto-generated-tracking-doc>/g;

  constructor(mdTargetFile: string, trackingConfigurationFile: string) {
    this.#mdTargetFile = mdTargetFile;
    this.#trackingConfigurationFile = trackingConfigurationFile;
  }

  static #arrayToString(values: string[]): string {
    return values ? `${values.map(val => `\`${val}\``).join(', ')}` : '';
  }

  static #renderParameterTemplate(
    parameter: TrackParameterType,
    indent = '    '
  ): string {
    const { key, description, purpose, example, values, optional } = parameter;

    const isRequired = optional === true ? 'false' : 'true';
    const allowedValues = TrackingDocumentationGenerator.#arrayToString(
      values ?? []
    );

    return `${indent}| \`${key}\` | ${description} | ${purpose} | ${isRequired} | ${allowedValues} | ${example}`;
  }

  static #renderEventTemplate(
    event: TrackEventType,
    recipient: string
  ): string {
    const { key, description, parameters } = event;
    const parametersView = parameters
      .filter(param =>
        param.recipients.includes(recipient as keyof typeof Recipient)
      )
      .map(param =>
        TrackingDocumentationGenerator.#renderParameterTemplate(param)
      )
      .join('\n');

    if (!parametersView) {
      return `
  - \`${key}\` ${description}
      `;
    }

    return `
  - \`${key}\` ${description}
    
    | param_name | description | purpose | required | values | example |
    | -          |-            |-        |-         | -      | -       |
${parametersView}
`;
  }

  static #renderTemplate(
    events: TrackEventType[],
    trackersConfiguration: Record<string, string>
  ): string {
    const reciptients = new Set(events.map(item => item.recipients).flat());

    const content = [...reciptients].map(recipient => {
      const trackers = Object.keys(trackersConfiguration).filter(tracker =>
        trackersConfiguration[tracker].includes(recipient)
      );
      return `
### ${recipient.toUpperCase()} (${trackers.join(', ')})

${events
  .filter(event => event.recipients.includes(recipient))
  .map(event =>
    TrackingDocumentationGenerator.#renderEventTemplate(event, recipient)
  )
  .join('\n')}


`;
    });

    return `<auto-generated-tracking-doc>

## Tracking events

${content.join('\n')}


</auto-generated-tracking-doc>`;
  }

  generateDocumentation(): {
    status: StatusType;
    content?: string;
  } {
    const trackingConfiguration = yaml.load(
      fs.readFileSync(this.#trackingConfigurationFile, 'utf8')
    ) as { EVENTS: TrackEventType[]; RECIPIENTS: Record<string, string> };
    const documentationContent = fs.readFileSync(this.#mdTargetFile, 'utf8');

    const events = Object.keys(trackingConfiguration.EVENTS).map(key => {
      const event =
        trackingConfiguration.EVENTS[
          key as keyof typeof trackingConfiguration.EVENTS
        ];
      return event;
    });

    this.#updatedContent = documentationContent.replace(
      this.#regReplacement,
      TrackingDocumentationGenerator.#renderTemplate(
        events as TrackEventType[],
        trackingConfiguration.RECIPIENTS as typeof trackingConfiguration.RECIPIENTS
      )
    );

    if (this.#updatedContent === documentationContent) {
      return {
        status: StatusType.IS_UP_TO_DATE,
        content: this.#updatedContent,
      };
    }

    return {
      status: StatusType.READY_TO_BE_SAVED,
      content: this.#updatedContent,
    };
  }

  saveGeneratedDocumentation(): { status: StatusType } {
    if (!this.#updatedContent) {
      return { status: StatusType.NEED_GENERATE };
    }
    if (!this.hasChanges) {
      return { status: StatusType.IS_UP_TO_DATE };
    }

    fs.writeFileSync(this.#mdTargetFile, this.#updatedContent);

    return { status: StatusType.UPDATED };
  }

  hasChanges(): boolean {
    if (!this.#updatedContent) {
      return false;
    }
    const documentationContent = fs.readFileSync(this.#mdTargetFile, 'utf8');
    return this.#updatedContent !== documentationContent;
  }

  getDiff(): Diff.Change[] {
    if (!this.#updatedContent) {
      return [];
    }
    const documentationContent = fs.readFileSync(this.#mdTargetFile, 'utf8');

    return diffLines(documentationContent, this.#updatedContent);
  }
}
